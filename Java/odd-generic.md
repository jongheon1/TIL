## Java 제네릭 설계의 특이점: Raw Type 생성자와 타입 안전성

Java 제네릭을 사용하면서 한 가지 특이한 점을 발견했다. 다음 코드를 살펴보자.

```java
Set<Integer> rawIntegerSet = new HashSet();  // Raw Type 생성자
rawIntegerSet.add(1);         // 정상 동작
rawIntegerSet.add("1");       // 컴파일 에러 발생

Set<Integer> integerSet = new HashSet<>();   // 다이아몬드 연산자
integerSet.add(1);            // 정상 동작
integerSet.add("1");          // 컴파일 에러 발생
```

여기서 주목할 점은 Raw Type 생성자를 사용했음에도 타입 체크가 정상적으로 동작한다는 것이다. 더욱이 다이아몬드 연산자를 사용한 경우와 동일하게 작동한다.

### 세 가지 생성 방식

제네릭 인스턴스는 다음과 같이 생성할 수 있다:

```java
Set<Integer> set1 = new HashSet<Integer>();  // Java 5 방식
Set<Integer> set2 = new HashSet<>();         // Java 7 이후
Set<Integer> set3 = new HashSet();           // Raw Type 생성자
```

세 방식 모두 동일한 동작을 보장한다. 이는 몇 가지 의문을 제기한다.

### 제기되는 의문점

1. 다이아몬드 연산자는 타입 선언의 간소화를 위해 도입되었다.
2. 그러나 Raw Type 생성자가 더 간단한 문법을 제공한다.
3. Raw Type 생성자를 사용해도 타입 안전성이 보장된다.

### 제네릭 설계의 특징

이러한 현상은 Java 제네릭 설계의 다음과 같은 특징을 보여준다:

1. 타입 안전성은 변수 선언의 제네릭 타입이 보장한다.
2. 생성자의 제네릭 표현은 형식적인 성격을 갖는다.
3. Raw Type도 제네릭 변수와 함께 사용되면 타입 안전성을 해치지 않는다.

### 결론: 하위 호환성이 만들어낸 오묘한 설계
이러한 특징은 Java의 하위 호환성 유지를 위한 노력의 결과로 보인다. 제네릭이 도입되면서 기존의 Raw Type 코드들과의 호환성을 유지해야 했고, 이는 의도치 않게 생성 방식의 유연성으로 이어졌다.

결과적으로 제네릭 변수 선언을 통해 타입 안전성은 확보하면서도, Raw Type 생성자도 허용하는 현재의 오묘한 형태가 되었다. 이는 Java가 추구하는 엄격한 타입 시스템과 레거시 코드와의 호환성 사이에서 어쩔 수 없이 만들어진 절충점이라 할 수 있다. 물론 새로운 코드에서는 다이아몬드 연산자의 사용이 권장되지만, 이러한 하위 호환성으로 인한 특이점은 Java 제네릭만의 독특한 특성으로 남게 되었다.

