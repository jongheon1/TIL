# equals 와 hashCode

### equals() 란?
다른 객체가 이 객체와 "동일한지"를 나타냅니다.
equals 메소드는 널이 아닌 객체 참조에 대한 동등 관계를 구현합니다.
이는 다음을 만족합니다.

- 널이 아닌 참조 값 x 에 대해서, x.equals(x) 는 true 를 반환해야합니다.
- 널이 아닌 참조 값 x 에 대해서, x.equals(y) 는 y.equals(x) 가 true 를 반환할 때만 true 를 반환해야합니다. (필요충분관계)
- 널이 아닌 참조 값 x, y, z 에 대해서, 만약 x.equals(y) 와 y.equals(z) 가 모두 true 를 반환한다면, x.equals(z) 도 true 를 반환해야합니다.
- 널이 아닌 참조 값 x, y 에 대해서, 객체에서 equals 비교에 사용된 정보가 수정되지 않는 한, x.equals(y) 는 일관되게 true 를 반환하거나 일관되게 false 를 반환합니다.
- 널이 아닌 참조 값 x 에 대해서, x.equals(null) 은 false 를 반환해야합니다.

동등 관계는 연산하는 요소를 동등 클래스로 분할하며, 동등 클래스의 모든 멤버는 서로 같습니다. 동등 클래스의 멤버들은 적어도 일부 목적으로는 서로를 대체 할 수 있습니다.

API Note:
equals 메소드 가 오버라이드 된다면 일반적으로 hashCode 메소드 또한 오버라이드 하는 것이 필요하다. 같은 객체는 같은 해시 코드를 가져야 한다는 hashCode 메소드 의 일반 규약을 유지할 수 있기 때문이다.

구현 요구 사항:
Object 클래스의 equals 메소드는 가능한 가장 차별적인 동등 관계를 구현합니다. 즉 널이 아닌 참조 값 x, y 에 대해서, x 와 y 가 동일한 객체를 참조하는 경우에만 true 를 반환합니다. 


### hashCode 란?
객체의 해시 코드를 반환합니다. 

hashCode 의 일반 규약:

- 자바 어플리케이션 실행 동안, 같은 객체에 대해 두번 이상 호출 될 때 마다, equals 비교에 사요된 정보가 수정되지 않는 한, hashCode 메소드는 일관되게 동일한 정수를 반환해야합니다. 이 정수는 같은 프로그램의 다른 실행까지 유지 될 필요는 없습니다.
- equals 메소드에 따라 두 객체가 같다면, 두 객체 각각에서 hashCode 메소드를 호출하면 같은 정수 결과가 생겨야 합니다.
- equals 메소드에 따라 두 객체가 같지 않더라도, 두 객체 각각에서 hashCode 메소드를 호출할 때 다른 정수 결과가 생겨야 할 필요는 없습니다. 그러나 다른 객체에 대해 다른 정수 값을 생성하는 것이 hash tables 의 성능을 향상 시킬 수도 있습니다.

---

일반적으로 equals 메서드는 두 객체가 같음을 판단할 때 사용한다. 기본 구현으로 Object 클래스의 equals 는 두 객체의 reference 가 같은지, 즉 두 객체가 메모리 상의 같은 위치를 가리키는지를 확인한다. 대부분의 경우 이것으로는 두 객체의 같음을 판단하기에 충분하지 않다. 예를 들어 두 'Person' 객체가 서로 다른 메모리 주소를 가리키고 있더라도, 이름 나이 등의 필드 값이 모두 같다면 이 두 객체는 '같은' 것으로 간주 할 수 있다. 이렇게 필드 값의 같음을 기준으로 두 객체의 같음을 정의 하는 것이 오버라이딩의 주된 목적이다. 
객체의 상태는 그 필드에 의해 정의된다. 그러므로 객체의 같음을 판단하는 방법은 그 필드를 검사함으로써 이루어져야한다.


hashCode 메서드는 객체에 대한 해시코드를 반환한다. 이때 해시코드는 한 객체에 대해 hashCode 메서드를 호출 할 때 마다 항상 일관된 값을 가진다. 또한 equals 에 따라 두 객체가 같다면, 두 객체 각각에서 hashCode 를 호출 했을 때 같은 값을 가져야 한다. 

hashCode 는 정의 상으로 equals 에 의존한다. equals 에 따라 두 객체가 같다면, 두 객체 각각에서 hashCode 를 호출 했을 때 같은 값을 가져야 하기 때문이다.

그렇다면 왜 둘을 함께 오버라이드 해야할까?

equals 는 오버라이드 하고, hashCode 는 오버라이드 하지 않는 상황을 가정해보자. equals 로 두 객체의 같음을 판단할 때에는, 객체의 필드의 같음으로 판단할 것이다. 두 객체의 reference 가 다르더라도 두 객체의 모든 필드 값이 같다면 true 를 반환할 것이다. 하지만 hashCode 는 여전히 객체의 reference 에 따른 값을 가진다. 그러므로 equals 는 true 더라도, hashCode 는 다른 값을 가지는 경우가 발생한다.
이는 hashCode 의 정의 상으로 맞지 않을 뿐만 아니라, 해시 기반 컬렉션에서 문제가 생길 수 있다.