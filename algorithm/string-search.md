
문자열에서 특정 접두사(prefix)로 시작하는 단어를 찾는 건 꽤 흔한 작업이다. List부터 시작해서 이진 탐색, 그리고 Trie까지 각 방식들의 특징과 한계점을 살펴보자.

**단순 비교 방식**

단순 비교 방식은 문자열을 저장하고 검색하는 가장 기본적인 방법으로, 모든 문자를 순차적으로 비교하는 방식이다. 이는 ArrayList와 같은 선형 자료구조를 사용하는 것이 일반적이다.

* 저장: O(L) 
  - 리스트 끝에 단순 추가하는 방식
  - 별도의 정렬이나 처리 과정이 필요 없어 매우 단순
  - 새로운 문자열의 길이에만 비례하는 시간 소요

* 검색: O(N * L)
  - 저장된 모든 문자열을 처음부터 끝까지 순차적으로 비교
  - 최악의 경우 마지막까지 검색해야 할 수 있음
  - 데이터가 많아질수록 검색 시간이 선형적으로 증가

* Prefix 검색: O(N * L)
  - 모든 문자열의 접두사를 하나씩 확인해야 함
  - 각 문자열마다 접두사 일치 여부를 체크
  - 전체 문자열을 모두 순회해야 하는 비효율


**이진 탐색 방식**

이진 탐색 방식은 단순 비교의 한계를 개선하기 위해 등장했다. 문자열들을 사전순으로 정렬된 상태로 유지하면서 중간 값과의 비교를 통해 검색 범위를 줄여나가는 방식이다.

* 저장: O(N * log N * L)
  - 정렬된 상태를 유지하기 위한 삽입 정렬 필요
  - 새로운 문자열 삽입 시 위치 탐색 과정 필요
  - 기존 요소들의 이동이 발생할 수 있음

* 검색: O(L * log N)
  - 이진 탐색으로 검색 범위를 절반씩 감소
  - 정렬된 상태를 활용해 효율적인 검색 가능
  - 단순 비교보다 획기적으로 개선된 검색 성능

* Prefix 검색: O(L * log N + k)
  - 이진 탐색으로 시작 위치를 찾음
  - 찾은 위치부터 k개의 일치하는 결과 수집
  - 단순 비교보다는 효율적이나 여전히 한계 존재


**두 방식의 한계점**

1. 공통적인 문제
   - Prefix 검색이 비효율적이다.
   - 저장된 문자열이 많아질수록 성능이 급격히 저하된다.

2. 실용적 한계
   - 자동 완성이나 사전 검색 같은 Prefix 기반 기능 구현이 어렵다.
   - 대용량 데이터 처리에 부적합하다.


이러한 한계점들을 해결하기 위해 Trie 자료구조가 등장하게 되었다.


**Trie**

Trie는 각 노드가 문자를 저장하고, 문자열을 루트에서 특정 노드까지의 경로로 표현하는 특별한 트리 구조를 가진다. 기본적인 노드 구조는 다음과 같다:

```java
class Node {
    Node[] nexts = new Node[26];  // 알파벳 소문자 전용
    boolean isEnd;                // 단어의 끝 표시
}
```

```
		 root
           |
           c
           |
           a
        /  |  \
       t   r   k
          /     \
         d       e
```

* 저장: O(L)
  - 문자열의 각 문자를 순서대로 노드로 만들어 추가
  - 이미 존재하는 노드는 재사용하여 공간 효율성 확보
  - 마지막 문자의 노드에 단어 끝 표시

* 검색: O(L)
  - 문자열의 각 문자를 따라 노드 순회
  - 중간에 노드가 없으면 실패
  - 마지막 노드의 단어 끝 표시로 완전 일치 여부 확인

* Prefix 검색: O(L)
  - 문자열의 각 문자를 따라 노드 순회
  - 해당 노드까지 도달 가능하면 prefix 존재
  - 추가 순회로 prefix로 시작하는 모든 단어 수집 가능


**장점**
1. Prefix 검색이 문자열 길이에만 비례
2. 공통 접두어를 한 번만 저장하여 공간 효율성 확보
3. 자동 완성, 사전 검색 등에 최적화된 성능


**실제 활용**
- 자동 완성 (검색어, 코드 등)
- 맞춤법 검사기

이처럼 Trie는 이전 방식들의 한계를 효과적으로 극복하며, 특히 Prefix 기반 검색에서 탁월한 성능을 보여준다. 저장 공간을 다소 더 사용하는 단점이 있지만, 검색 성능에서의 이점이 이를 충분히 상쇄한다.